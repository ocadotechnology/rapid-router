# Generated by Django 5.1.10 on 2025-06-10 12:11
from django.apps.registry import Apps
from django.db import migrations, models
from django.db.models import F, Q

attempt_data = {}


def delete_incomplete_attempts(apps: Apps, *args):
    Attempt = apps.get_model("game", "Attempt")

    Attempt.objects.filter(
        Q(score__isnull=True)
        | Q(start_time__isnull=True)
        | Q(finish_time__isnull=True)
    ).delete()


def collect_attempt_data(apps: Apps, *args):
    """
    For every student and for every level, collect all attempts.
    1 entry per student per level.
    1 entry = 1 new Attempt object:
    - time_spent = sum of elapsed time of all attempts, converted to seconds
    - score = score if best_attempt
    - count = len(attempts)
    Also, for each attempt processed, increment the corresponding daily activity counter.
    """
    Attempt = apps.get_model("game", "Attempt")
    Level = apps.get_model("game", "Level")
    DailyActivity = apps.get_model("game", "DailyActivity")
    Student = apps.get_model("common", "Student")

    for student in Student.objects.all().iterator(chunk_size=5000):
        # Collect student's attempts
        student_attempts = Attempt.objects.filter(student=student)

        # If a student doesn't have any complete attempt, move on to next student
        if len(student_attempts) == 0:
            continue

        student_attempts_data = {}

        for level in Level.objects.all().iterator(chunk_size=5000):
            # Collect all attempts for that level
            attempts_per_level = student_attempts.filter(level=level)

            # If a there are no attempts for that level, move on to the next level
            if len(attempts_per_level) == 0:
                continue

            # Aggregate the number of attempt rows into the new count field
            count = len(attempts_per_level)

            # Get the best attempt's score and save that as the value for the score field
            best_attempt = attempts_per_level.filter(is_best_attempt=True)
            assert len(best_attempt) == 1
            score = best_attempt[0].score

            time_spent = 0

            # Calculate sum of time spent on all attempts for that level and save to new time_spent field
            # and increment DailyActivity table to keep track of daily attempt count
            for attempt in attempts_per_level.iterator(chunk_size=1000):
                # Attempt is in Python Den if level is an "official" level and the level's name (id) is over 1000
                daily_activity_field = (
                    "pd_attempt_count"
                    if level.owner is None
                    and level.episode is not None
                    and int(level.name) > 1000
                    else "rr_attempt_count"
                )
                DailyActivity.objects.update_or_create(
                    date=attempt.finish_time.date(),
                    defaults={
                        daily_activity_field: F(daily_activity_field) + 1,
                    },
                    create_defaults={
                        daily_activity_field: 1,
                    },
                )

                attempt_duration = int(
                    (attempt.finish_time - attempt.start_time).total_seconds()
                )
                time_spent += attempt_duration

            # Save the attempt data as a new entry in the dict for that level
            level_attempts_data = {
                "count": count,
                "time_spent": time_spent,
                "score": score,
            }
            student_attempts_data[level.pk] = level_attempts_data

        # Save all attempt data for all levels in the dict for that student
        attempt_data[student.pk] = student_attempts_data


def delete_remaining_attempts(apps: Apps, *args):
    Attempt = apps.get_model("game", "Attempt")

    Attempt.objects.all().delete()


def aggregate_attempts(apps: Apps, *args):
    Attempt = apps.get_model("game", "Attempt")
    Level = apps.get_model("game", "Level")
    Student = apps.get_model("common", "Student")

    for student, levels in attempt_data.items():
        for level, level_data in levels.items():
            Attempt(
                time_spent=level_data["time_spent"],
                level=Level.objects.get(pk=level),
                student=Student.objects.get(pk=student),
                score=level_data["score"],
                count=level_data["count"],
            ).save()


class Migration(migrations.Migration):

    dependencies = [
        ("game", "0118_dailyactivity"),
    ]

    operations = [
        migrations.RunPython(code=delete_incomplete_attempts),
        migrations.RunPython(code=collect_attempt_data),
        migrations.RemoveField(
            model_name="attempt",
            name="finish_time",
        ),
        migrations.RemoveField(
            model_name="attempt",
            name="is_best_attempt",
        ),
        migrations.RemoveField(
            model_name="attempt",
            name="night_mode",
        ),
        migrations.RemoveField(
            model_name="attempt",
            name="python_workspace",
        ),
        migrations.RemoveField(
            model_name="attempt",
            name="start_time",
        ),
        migrations.RemoveField(
            model_name="attempt",
            name="workspace",
        ),
        migrations.AddField(
            model_name="attempt",
            name="count",
            field=models.IntegerField(blank=True, default=0, null=True),
        ),
        migrations.AddField(
            model_name="attempt",
            name="time_spent",
            field=models.BigIntegerField(blank=True, default=0, null=True),
        ),
        migrations.AlterField(
            model_name="attempt",
            name="score",
            field=models.FloatField(blank=True, default=0, null=True),
        ),
        migrations.RunPython(code=delete_remaining_attempts),
        migrations.RunPython(code=aggregate_attempts),
    ]
